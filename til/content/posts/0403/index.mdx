---
title: "TIL-클로저, ES6, ES11"
date: 2021-04-03
tags:
  - TIL
  - JS
---

## 클로저

일반적으로 외부 함수의 실행이 끝나면, 외부 함수가 소멸되어 내부 함수가 외부 함수의 변수에 접근할 수 없다.

하지만 **외부 함수의 실행이 끝나고 외부 함수가 소멸된 이후에도 내부 함수가 외부 함수의 변수에 접근할 수 있는 구조** 를 **클로저**라고 한다

- 자신의 고유 스코프를 가진 상태로 소멸하지 않고, 외부 함수에 의해 호출되는 함수를 만드는 것

<br />

```js
var num = 1;

function foo() {
  var num = 2;

  function bar() {
    console.log(num);
  }
  return bar;
}

var baz = foo();
baz(); // => 2
```

위 코드에서

외부 함수 `foo()`는 리턴되어 사라진 후, 내부 함수 `bar()`가 생성된다.

그러나 여전히 내부 함수가 외부함수의 지역 변수에 접근할 수 있다.

외부 함수가 사라지지 않고 내부 함수의 참조로 인해 값을 유지하게 되는 것

이것을 클로저라고 부른다.

위 코드에선 내부 함수인 `bar()`를 **클로저 함수**라고 부른다.

```js
function f(arg) {
  var n = function () {
    return arg;
  };
  arg++;
  return n;
}

var m = f(123);
console.log(m()); // => 124
```

HA시험에서 클로저 부분이 제일 어려웠다...

---

# ES6

참고 자료 - 드림코딩 by 엘리, 모던JS튜토리얼

### 화살표 함수

```js
// 화살표 함수
arr.map((arg) => {...})

// 괄호 생략 가능
arr.map(arg => ...)
```

### 클래스

```js
    // 클래스
    class MyClass {
        constructor() {...}
        method() {...}
        ...
    }

    // 예제
    class User {

    constructor(name) {
        this.name = name;
    }

    sayHi() {
        alert(this.name);
    }

    }

    // 사용법:
    let user = new User("John");
    user.sayHi();
```

예전에 정리했었는데 까먹었다...

### Destructuring assignment

```js
  // 객체
  const student = {
    name: 'Anna',
    level: 1,
  };

  // 💩
    const name = student.name;
    const level = student.level;
    console.log(name, level); // => "Anna" 1

  // ✨
    // 동일 이름으로 선언
    const { name, level } = student;
    console.log(name, level); // => "Anna" 1

    // 새로운 이름으로 선언
    const { name: studentName, level: studentLevel } = student;
    console.log(studentName, studentLevel); // => "Anna" 1

  // 배열
  const animals = ['🐶', '😽'];

  // 💩
  {
    const first = animals[0];
    const second = animals[1];
    console.log(first, second); // => 🐶 😽
  }

  // ✨
  {
    const [first, second] = animals;
    console.log(first, second); // => 🐶 😽
  }
}

```

훔..

```js
// 이름과 성을 요소로 가진 배열
let arr = ["Bora", "Lee"];

// 구조 분해 할당을 이용해
// firstName엔 arr[0]을
// surname엔 arr[1]을 할당하였습니다.
let [firstName, surname] = arr;

alert(firstName); // Bora
alert(surname); // Lee
```

### Default parameters

```js
function func(userName = "홍길동") {
  console.log(userName);
}

func("김솔희"); // => "김솔희"
func(); // => "홍길동"
```

### 삼항 조건 연산자

```js
const isCat = true;

// 💩
{
  let component;
  if (isCat) {
    component = "😸";
  } else {
    component = "🐶";
  }
  console.log(component); // => 😸
}

// ✨
{
  const component = isCat ? "😸" : "🐶"; // isCat 이 true일 경우 고양이, 아니라면 강아지
  console.log(component); // => 😸
}
```

# ES11

### 옵셔널 체이닝

```js
// 옵셔널 체이닝이 필요한 이유
let user = {}; // 주소 정보가 없는 사용자

alert(user.address.street.name); // TypeError: Cannot read property 'street' of undefined

// 똥 코드
alert(user && user.address && user.address.street && user.address.street.name); // undefined, 에러가 발생하지 않습니다.

// 똥 코드2
alert(
  user.address
    ? user.address.street
      ? user.address.street.name
      : undefined
    : undefined
);

// 갓 코드
alert(user?.address?.street); // undefined, 에러가 발생하지 않습니다.
```

### null 병합 연산자 '??'

```js
{
  const name = "Ellie";
  const userName = name || "Guest";
  console.log(userName);
}

{
  const name = null;
  const userName = name || "Guest";
  console.log(userName);
}

// 💩🐞🕷🦗🦟🐜 버그 덩어리
{
  const name = "";
  const userName = name || "Guest"; // 빈 문자열은 펄시한 값
  console.log(userName); // => Guest

  const num = 0;
  const message = num || "undefined"; // 0은 펄시
  console.log(message); // => undefined
}

// ✨
{
  const name = "";
  const userName = name ?? "Guest";
  console.log(userName); // => ""

  const num = 0;
  const message = num ?? "undefined";
  console.log(message); // => 0
}
```
